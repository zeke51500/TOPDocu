{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import type MarkdownIt from \"markdown-it/lib\"\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.js\"\nimport type Token from \"markdown-it/lib/token.js\"\n\n/** Parse MyST targets (``(name)=``), blockquotes (``% comment``) and block breaks (``+++``).\n *\n * Adapted from: mdit_py_plugins/myst_blocks/index.py\n */\nexport function mystBlockPlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"blockquote\", \"myst_line_comment\", parse_line_comment, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_block_break\", parse_block_break, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_target\", parse_target, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.renderer.rules.myst_line_comment = render_myst_line_comment\n  md.renderer.rules.myst_target = render_myst_target\n}\n\nfunction parse_line_comment(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (state.src[pos] !== \"%\") {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  const token = state.push(\"myst_line_comment\", \"\", 0)\n  token.attrSet(\"class\", \"myst-line-comment\")\n  token.content = state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  token.markup = \"%\"\n\n  // search end of block while appending lines to `token.content`\n  let nextLine: number\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    maximum = state.eMarks[nextLine]\n    if (state.src[pos] !== \"%\") {\n      break\n    }\n    token.content += \"\\n\" + state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  }\n  state.line = nextLine\n  token.map = [startLine, nextLine]\n\n  return true\n}\n\nfunction parse_block_break(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n  pos += 1\n\n  // Check block marker /* + */\n  if (marker !== 0x2b) {\n    return false\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  let cnt = 1\n  while (pos < maximum) {\n    const ch = state.src.charCodeAt(pos)\n    if (ch !== marker && !state.md.utils.isSpace(ch)) {\n      break\n    }\n    if (ch === marker) {\n      cnt += 1\n    }\n    pos += 1\n  }\n\n  if (cnt < 3) {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_block_break\", \"hr\", 0)\n  token.attrSet(\"class\", \"myst-block\")\n  token.content = state.src.slice(pos, maximum).trim()\n  token.map = [startLine, state.line]\n  token.markup = state.md.utils.fromCodePoint(marker).repeat(cnt)\n\n  return true\n}\n\nconst TARGET_PATTERN = /^\\((?<label>[a-zA-Z0-9|@<>*./_\\-+:]{1,100})\\)=\\s*$/\n\nfunction parse_target(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  const pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n  const match = TARGET_PATTERN.exec(state.src.slice(pos, maximum))\n  if (!match) {\n    return false\n  }\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_target\", \"\", 0)\n  token.attrSet(\"class\", \"myst-target\")\n  token.content = match && match.groups ? match.groups[\"label\"] : \"\"\n  token.map = [startLine, state.line]\n\n  return true\n}\n\nfunction escapeHtml(unsafe: string) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\")\n}\n\nfunction render_myst_line_comment(tokens: Token[], idx: number): string {\n  const token = tokens[idx]\n  const content = token.content\n  return `<!-- ${escapeHtml(content).trim()} -->`\n}\n\nfunction render_myst_target(tokens: Token[], idx: number) {\n  const token = tokens[idx]\n  const className = \"myst-target\"\n  const label = token.content\n  const target = `<a href=\"#${label}\">(${label})=</a>`\n  return `<div class=\"${className}\">${target}</div>`\n}\n\n/** Colon fence\n * This plugin directly mimics regular fences, but with `:` colons.\n *\n * Example:\n\n        :::name\n        contained text\n        :::\n *\n*/\nexport function colonFencePlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"fence\", \"colon_fence\", colon_fence_rule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n}\n\nfunction colon_fence_rule(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let haveEndMarker = false\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (pos + 3 > max) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x3a /* : */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) {\n    return false\n  }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) {\n    return true\n  }\n\n  // search end of block\n  let nextLine = startLine\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) {\n      continue\n    }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) {\n      continue\n    }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token = state.push(\"fence\", \"code\", 0)\n  token.info = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup = markup\n  token.map = [startLine, state.line]\n\n  return true\n}\n"],"names":[],"mappings":"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"}