{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["import type MarkdownIt from \"markdown-it/lib\"\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.js\"\nimport type Token from \"markdown-it/lib/token.js\"\n\n/** Parse MyST targets (``(name)=``), blockquotes (``% comment``) and block breaks (``+++``).\n *\n * Adapted from: mdit_py_plugins/myst_blocks/index.py\n */\nexport function mystBlockPlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"blockquote\", \"myst_line_comment\", parse_line_comment, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_block_break\", parse_block_break, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_target\", parse_target, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.renderer.rules.myst_line_comment = render_myst_line_comment\n  md.renderer.rules.myst_target = render_myst_target\n}\n\nfunction parse_line_comment(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (state.src[pos] !== \"%\") {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  const token = state.push(\"myst_line_comment\", \"\", 0)\n  token.attrSet(\"class\", \"myst-line-comment\")\n  token.content = state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  token.markup = \"%\"\n\n  // search end of block while appending lines to `token.content`\n  let nextLine: number\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    maximum = state.eMarks[nextLine]\n    if (state.src[pos] !== \"%\") {\n      break\n    }\n    token.content += \"\\n\" + state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  }\n  state.line = nextLine\n  token.map = [startLine, nextLine]\n\n  return true\n}\n\nfunction parse_block_break(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n  pos += 1\n\n  // Check block marker /* + */\n  if (marker !== 0x2b) {\n    return false\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  let cnt = 1\n  while (pos < maximum) {\n    const ch = state.src.charCodeAt(pos)\n    if (ch !== marker && !state.md.utils.isSpace(ch)) {\n      break\n    }\n    if (ch === marker) {\n      cnt += 1\n    }\n    pos += 1\n  }\n\n  if (cnt < 3) {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_block_break\", \"hr\", 0)\n  token.attrSet(\"class\", \"myst-block\")\n  token.content = state.src.slice(pos, maximum).trim()\n  token.map = [startLine, state.line]\n  token.markup = state.md.utils.fromCodePoint(marker).repeat(cnt)\n\n  return true\n}\n\nconst TARGET_PATTERN = /^\\((?<label>[a-zA-Z0-9|@<>*./_\\-+:]{1,100})\\)=\\s*$/\n\nfunction parse_target(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  const pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n  const match = TARGET_PATTERN.exec(state.src.slice(pos, maximum))\n  if (!match) {\n    return false\n  }\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_target\", \"\", 0)\n  token.attrSet(\"class\", \"myst-target\")\n  token.content = match && match.groups ? match.groups[\"label\"] : \"\"\n  token.map = [startLine, state.line]\n\n  return true\n}\n\nfunction escapeHtml(unsafe: string) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\")\n}\n\nfunction render_myst_line_comment(tokens: Token[], idx: number): string {\n  const token = tokens[idx]\n  const content = token.content\n  return `<!-- ${escapeHtml(content).trim()} -->`\n}\n\nfunction render_myst_target(tokens: Token[], idx: number) {\n  const token = tokens[idx]\n  const className = \"myst-target\"\n  const label = token.content\n  const target = `<a href=\"#${label}\">(${label})=</a>`\n  return `<div class=\"${className}\">${target}</div>`\n}\n\n/** Colon fence\n * This plugin directly mimics regular fences, but with `:` colons.\n *\n * Example:\n\n        :::name\n        contained text\n        :::\n *\n*/\nexport function colonFencePlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"fence\", \"colon_fence\", colon_fence_rule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n}\n\nfunction colon_fence_rule(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let haveEndMarker = false\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (pos + 3 > max) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x3a /* : */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) {\n    return false\n  }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) {\n    return true\n  }\n\n  // search end of block\n  let nextLine = startLine\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) {\n      continue\n    }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) {\n      continue\n    }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token = state.push(\"fence\", \"code\", 0)\n  token.info = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup = markup\n  token.map = [startLine, state.line]\n\n  return true\n}\n"],"names":["parse_line_comment","state","startLine","endLine","silent","pos","bMarks","tShift","maximum","eMarks","sCount","blkIndent","src","token","push","nextLine","attrSet","content","slice","replace","markup","line","map","parse_block_break","marker","charCodeAt","cnt","ch","md","utils","isSpace","trim","fromCodePoint","repeat","TARGET_PATTERN","parse_target","match","exec","groups","render_myst_line_comment","tokens","idx","unsafe","render_myst_target","label","colon_fence_rule","haveEndMarker","max","mem","skipChars","len","params","skipSpaces","info","getLines","block","ruler","before","alt","renderer","rules","myst_line_comment","myst_target"],"mappings":"2PAsBA,SAASA,EACPC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAMJ,EAAMK,OAAOJ,GAAaD,EAAMM,OAAOL,GAC7CM,EAAUP,EAAMQ,OAAOP,GAG3B,GAAID,EAAMS,OAAOR,GAAaD,EAAMU,WAAa,EAC/C,OAAO,EAGT,GAAuB,MAAnBV,EAAMW,IAAIP,GACZ,OAAO,EAGT,GAAID,EACF,OAAO,EAGT,MAAMS,EAAQZ,EAAMa,KAAK,oBAAqB,GAAI,GAMlD,IAAIC,EACJ,IANAF,EAAMG,QAAQ,QAAS,qBACvBH,EAAMI,QAAUhB,EAAMW,IAAIM,MAAMb,EAAM,EAAGG,GAASW,QAAQ,SAAU,IACpEN,EAAMO,OAAS,IAIVL,EAAWb,EAAY,EAAGa,EAAWZ,IACxCE,EAAMJ,EAAMK,OAAOS,GAAYd,EAAMM,OAAOQ,GAC5CP,EAAUP,EAAMQ,OAAOM,GACA,MAAnBd,EAAMW,IAAIP,IAHmCU,IAMjDF,EAAMI,SAAW,KAAOhB,EAAMW,IAAIM,MAAMb,EAAM,EAAGG,GAASW,QAAQ,SAAU,IAK9E,OAHAlB,EAAMoB,KAAON,EACbF,EAAMS,IAAM,CAACpB,EAAWa,IAEjB,CACT,CAEA,SAASQ,EACPtB,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAMJ,EAAMK,OAAOJ,GAAaD,EAAMM,OAAOL,GACjD,MAAMM,EAAUP,EAAMQ,OAAOP,GAG7B,GAAID,EAAMS,OAAOR,GAAaD,EAAMU,WAAa,EAC/C,OAAO,EAGT,MAAMa,EAASvB,EAAMW,IAAIa,WAAWpB,GAIpC,GAHAA,GAAO,EAGQ,KAAXmB,EACF,OAAO,EAKT,IAAIE,EAAM,EACV,KAAOrB,EAAMG,GAAS,CACpB,MAAMmB,EAAK1B,EAAMW,IAAIa,WAAWpB,GAChC,GAAIsB,IAAOH,IAAWvB,EAAM2B,GAAGC,MAAMC,QAAQH,GAC3C,MAEEA,IAAOH,IACTE,GAAO,GAETrB,GAAO,CACR,CAED,GAAIqB,EAAM,EACR,OAAO,EAGT,GAAItB,EACF,OAAO,EAGTH,EAAMoB,KAAOnB,EAAY,EAEzB,MAAMW,EAAQZ,EAAMa,KAAK,mBAAoB,KAAM,GAMnD,OALAD,EAAMG,QAAQ,QAAS,cACvBH,EAAMI,QAAUhB,EAAMW,IAAIM,MAAMb,EAAKG,GAASuB,OAC9ClB,EAAMS,IAAM,CAACpB,EAAWD,EAAMoB,MAC9BR,EAAMO,OAASnB,EAAM2B,GAAGC,MAAMG,cAAcR,GAAQS,OAAOP,IAEpD,CACT,CAEA,MAAMQ,EAAiB,qDAEvB,SAASC,EACPlC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAMJ,EAAMK,OAAOJ,GAAaD,EAAMM,OAAOL,GAC7CM,EAAUP,EAAMQ,OAAOP,GAG7B,GAAID,EAAMS,OAAOR,GAAaD,EAAMU,WAAa,EAC/C,OAAO,EAET,MAAMyB,EAAQF,EAAeG,KAAKpC,EAAMW,IAAIM,MAAMb,EAAKG,IACvD,IAAK4B,EACH,OAAO,EAET,GAAIhC,EACF,OAAO,EAGTH,EAAMoB,KAAOnB,EAAY,EAEzB,MAAMW,EAAQZ,EAAMa,KAAK,cAAe,GAAI,GAK5C,OAJAD,EAAMG,QAAQ,QAAS,eACvBH,EAAMI,QAAUmB,GAASA,EAAME,OAASF,EAAME,OAAc,MAAI,GAChEzB,EAAMS,IAAM,CAACpB,EAAWD,EAAMoB,OAEvB,CACT,CAWA,SAASkB,EAAyBC,EAAiBC,GACjD,MACMxB,EADQuB,EAAOC,GACCxB,QACtB,MAAO,YAZWyB,EAYQzB,EAXnByB,EACJvB,QAAQ,KAAM,SACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,UACdA,QAAQ,KAAM,WAMkBY,gBAZrC,IAAoBW,CAapB,CAEA,SAASC,EAAmBH,EAAiBC,GAC3C,MAEMG,EAFQJ,EAAOC,GAEDxB,QAEpB,MAAO,4BADQ,aAAa2B,OAAWA,iBAEzC,CAkBA,SAASC,EACP5C,EACAC,EACAC,EACAC,GAEA,IAAI0C,GAAgB,EAChBzC,EAAMJ,EAAMK,OAAOJ,GAAaD,EAAMM,OAAOL,GAC7C6C,EAAM9C,EAAMQ,OAAOP,GAGvB,GAAID,EAAMS,OAAOR,GAAaD,EAAMU,WAAa,EAC/C,OAAO,EAGT,GAAIN,EAAM,EAAI0C,EACZ,OAAO,EAGT,MAAMvB,EAASvB,EAAMW,IAAIa,WAAWpB,GAEpC,GAAe,KAAXmB,EACF,OAAO,EAIT,IAAIwB,EAAM3C,EACVA,EAAMJ,EAAMgD,UAAU5C,EAAKmB,GAE3B,IAAI0B,EAAM7C,EAAM2C,EAEhB,GAAIE,EAAM,EACR,OAAO,EAGT,MAAM9B,EAASnB,EAAMW,IAAIM,MAAM8B,EAAK3C,GAC9B8C,EAASlD,EAAMW,IAAIM,MAAMb,EAAK0C,GAGpC,GAAI3C,EACF,OAAO,EAIT,IAAIW,EAAWb,EAEf,MACEa,MACIA,GAAYZ,MAMhBE,EAAM2C,EAAM/C,EAAMK,OAAOS,GAAYd,EAAMM,OAAOQ,GAClDgC,EAAM9C,EAAMQ,OAAOM,KAEfV,EAAM0C,GAAO9C,EAAMS,OAAOK,GAAYd,EAAMU,aAOhD,GAAIV,EAAMW,IAAIa,WAAWpB,KAASmB,KAI9BvB,EAAMS,OAAOK,GAAYd,EAAMU,WAAa,IAKhDN,EAAMJ,EAAMgD,UAAU5C,EAAKmB,GAGvBnB,EAAM2C,EAAME,IAKhB7C,EAAMJ,EAAMmD,WAAW/C,GAEnBA,EAAM0C,KAAV,CAIAD,GAAgB,EAEhB,KAJC,CAQHI,EAAMjD,EAAMS,OAAOR,GAEnBD,EAAMoB,KAAON,GAAY+B,EAAgB,EAAI,GAE7C,MAAMjC,EAAQZ,EAAMa,KAAK,QAAS,OAAQ,GAM1C,OALAD,EAAMwC,KAAOF,EACbtC,EAAMI,QAAUhB,EAAMqD,SAASpD,EAAY,EAAGa,EAAUmC,GAAK,GAC7DrC,EAAMO,OAASA,EACfP,EAAMS,IAAM,CAACpB,EAAWD,EAAMoB,OAEvB,CACT,oBA9GM,SAA2BO,GAC/BA,EAAG2B,MAAMC,MAAMC,OAAO,QAAS,cAAeZ,EAAkB,CAC9Da,IAAK,CAAC,YAAa,YAAa,aAAc,OAAQ,iBAE1D,oBAtLM,SAA0B9B,GAC9BA,EAAG2B,MAAMC,MAAMC,OAAO,aAAc,oBAAqBzD,EAAoB,CAC3E0D,IAAK,CAAC,YAAa,YAAa,aAAc,OAAQ,kBAExD9B,EAAG2B,MAAMC,MAAMC,OAAO,KAAM,mBAAoBlC,EAAmB,CACjEmC,IAAK,CAAC,YAAa,YAAa,aAAc,OAAQ,kBAExD9B,EAAG2B,MAAMC,MAAMC,OAAO,KAAM,cAAetB,EAAc,CACvDuB,IAAK,CAAC,YAAa,YAAa,aAAc,OAAQ,kBAExD9B,EAAG+B,SAASC,MAAMC,kBAAoBtB,EACtCX,EAAG+B,SAASC,MAAME,YAAcnB,CAClC"}