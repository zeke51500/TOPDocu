{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["import type MarkdownIt from \"markdown-it/lib\"\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.js\"\nimport type Token from \"markdown-it/lib/token.js\"\n\n/** Parse MyST targets (``(name)=``), blockquotes (``% comment``) and block breaks (``+++``).\n *\n * Adapted from: mdit_py_plugins/myst_blocks/index.py\n */\nexport function mystBlockPlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"blockquote\", \"myst_line_comment\", parse_line_comment, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_block_break\", parse_block_break, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_target\", parse_target, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.renderer.rules.myst_line_comment = render_myst_line_comment\n  md.renderer.rules.myst_target = render_myst_target\n}\n\nfunction parse_line_comment(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (state.src[pos] !== \"%\") {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  const token = state.push(\"myst_line_comment\", \"\", 0)\n  token.attrSet(\"class\", \"myst-line-comment\")\n  token.content = state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  token.markup = \"%\"\n\n  // search end of block while appending lines to `token.content`\n  let nextLine: number\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    maximum = state.eMarks[nextLine]\n    if (state.src[pos] !== \"%\") {\n      break\n    }\n    token.content += \"\\n\" + state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  }\n  state.line = nextLine\n  token.map = [startLine, nextLine]\n\n  return true\n}\n\nfunction parse_block_break(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n  pos += 1\n\n  // Check block marker /* + */\n  if (marker !== 0x2b) {\n    return false\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  let cnt = 1\n  while (pos < maximum) {\n    const ch = state.src.charCodeAt(pos)\n    if (ch !== marker && !state.md.utils.isSpace(ch)) {\n      break\n    }\n    if (ch === marker) {\n      cnt += 1\n    }\n    pos += 1\n  }\n\n  if (cnt < 3) {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_block_break\", \"hr\", 0)\n  token.attrSet(\"class\", \"myst-block\")\n  token.content = state.src.slice(pos, maximum).trim()\n  token.map = [startLine, state.line]\n  token.markup = state.md.utils.fromCodePoint(marker).repeat(cnt)\n\n  return true\n}\n\nconst TARGET_PATTERN = /^\\((?<label>[a-zA-Z0-9|@<>*./_\\-+:]{1,100})\\)=\\s*$/\n\nfunction parse_target(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  const pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n  const match = TARGET_PATTERN.exec(state.src.slice(pos, maximum))\n  if (!match) {\n    return false\n  }\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_target\", \"\", 0)\n  token.attrSet(\"class\", \"myst-target\")\n  token.content = match && match.groups ? match.groups[\"label\"] : \"\"\n  token.map = [startLine, state.line]\n\n  return true\n}\n\nfunction escapeHtml(unsafe: string) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\")\n}\n\nfunction render_myst_line_comment(tokens: Token[], idx: number): string {\n  const token = tokens[idx]\n  const content = token.content\n  return `<!-- ${escapeHtml(content).trim()} -->`\n}\n\nfunction render_myst_target(tokens: Token[], idx: number) {\n  const token = tokens[idx]\n  const className = \"myst-target\"\n  const label = token.content\n  const target = `<a href=\"#${label}\">(${label})=</a>`\n  return `<div class=\"${className}\">${target}</div>`\n}\n\n/** Colon fence\n * This plugin directly mimics regular fences, but with `:` colons.\n *\n * Example:\n\n        :::name\n        contained text\n        :::\n *\n*/\nexport function colonFencePlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"fence\", \"colon_fence\", colon_fence_rule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n}\n\nfunction colon_fence_rule(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let haveEndMarker = false\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (pos + 3 > max) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x3a /* : */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) {\n    return false\n  }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) {\n    return true\n  }\n\n  // search end of block\n  let nextLine = startLine\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) {\n      continue\n    }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) {\n      continue\n    }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token = state.push(\"fence\", \"code\", 0)\n  token.info = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup = markup\n  token.map = [startLine, state.line]\n\n  return true\n}\n"],"names":[],"mappings":"AAIA;;;AAGG;AACG,SAAU,eAAe,CAAC,EAAc,EAAA;AAC5C,IAAA,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,EAAE,mBAAmB,EAAE,kBAAkB,EAAE;QAC3E,GAAG,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,EAAE,cAAc,CAAC;AACtE,KAAA,CAAC,CAAA;AACF,IAAA,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,kBAAkB,EAAE,iBAAiB,EAAE;QACjE,GAAG,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,EAAE,cAAc,CAAC;AACtE,KAAA,CAAC,CAAA;AACF,IAAA,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,aAAa,EAAE,YAAY,EAAE;QACvD,GAAG,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,EAAE,cAAc,CAAC;AACtE,KAAA,CAAC,CAAA;IACF,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,iBAAiB,GAAG,wBAAwB,CAAA;IAC9D,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,GAAG,kBAAkB,CAAA;AACpD,CAAC;AAED,SAAS,kBAAkB,CACzB,KAAiB,EACjB,SAAiB,EACjB,OAAe,EACf,MAAe,EAAA;AAEf,IAAA,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;IAC3D,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;;AAGrC,IAAA,IAAI,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,SAAS,IAAI,CAAC,EAAE;AAClD,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;IAED,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;AAC1B,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;AAED,IAAA,IAAI,MAAM,EAAE;AACV,QAAA,OAAO,IAAI,CAAA;AACZ,KAAA;AAED,IAAA,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,mBAAmB,EAAE,EAAE,EAAE,CAAC,CAAC,CAAA;AACpD,IAAA,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAA;IAC3C,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAA;AACvE,IAAA,KAAK,CAAC,MAAM,GAAG,GAAG,CAAA;;AAGlB,IAAA,IAAI,QAAgB,CAAA;AACpB,IAAA,KAAK,QAAQ,GAAG,SAAS,GAAG,CAAC,EAAE,QAAQ,GAAG,OAAO,EAAE,QAAQ,EAAE,EAAE;AAC7D,QAAA,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;AACrD,QAAA,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;QAChC,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;YAC1B,MAAK;AACN,SAAA;QACD,KAAK,CAAC,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAA;AAChF,KAAA;AACD,IAAA,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAA;IACrB,KAAK,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAA;AAEjC,IAAA,OAAO,IAAI,CAAA;AACb,CAAC;AAED,SAAS,iBAAiB,CACxB,KAAiB,EACjB,SAAiB,EACjB,OAAe,EACf,MAAe,EAAA;AAEf,IAAA,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;IAC3D,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;;AAGvC,IAAA,IAAI,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,SAAS,IAAI,CAAC,EAAE;AAClD,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;IAED,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;IACxC,GAAG,IAAI,CAAC,CAAA;;IAGR,IAAI,MAAM,KAAK,IAAI,EAAE;AACnB,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;;IAID,IAAI,GAAG,GAAG,CAAC,CAAA;IACX,OAAO,GAAG,GAAG,OAAO,EAAE;QACpB,MAAM,EAAE,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;AACpC,QAAA,IAAI,EAAE,KAAK,MAAM,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;YAChD,MAAK;AACN,SAAA;QACD,IAAI,EAAE,KAAK,MAAM,EAAE;YACjB,GAAG,IAAI,CAAC,CAAA;AACT,SAAA;QACD,GAAG,IAAI,CAAC,CAAA;AACT,KAAA;IAED,IAAI,GAAG,GAAG,CAAC,EAAE;AACX,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;AAED,IAAA,IAAI,MAAM,EAAE;AACV,QAAA,OAAO,IAAI,CAAA;AACZ,KAAA;AAED,IAAA,KAAK,CAAC,IAAI,GAAG,SAAS,GAAG,CAAC,CAAA;AAE1B,IAAA,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA;AACrD,IAAA,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,YAAY,CAAC,CAAA;AACpC,IAAA,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,IAAI,EAAE,CAAA;IACpD,KAAK,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,IAAI,CAAC,CAAA;AACnC,IAAA,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;AAE/D,IAAA,OAAO,IAAI,CAAA;AACb,CAAC;AAED,MAAM,cAAc,GAAG,oDAAoD,CAAA;AAE3E,SAAS,YAAY,CACnB,KAAiB,EACjB,SAAiB,EACjB,OAAe,EACf,MAAe,EAAA;AAEf,IAAA,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;IAC7D,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;;AAGvC,IAAA,IAAI,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,SAAS,IAAI,CAAC,EAAE;AAClD,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;AACD,IAAA,MAAM,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,CAAA;IAChE,IAAI,CAAC,KAAK,EAAE;AACV,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;AACD,IAAA,IAAI,MAAM,EAAE;AACV,QAAA,OAAO,IAAI,CAAA;AACZ,KAAA;AAED,IAAA,KAAK,CAAC,IAAI,GAAG,SAAS,GAAG,CAAC,CAAA;AAE1B,IAAA,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,EAAE,CAAC,CAAC,CAAA;AAC9C,IAAA,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,aAAa,CAAC,CAAA;IACrC,KAAK,CAAC,OAAO,GAAG,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAA;IAClE,KAAK,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,IAAI,CAAC,CAAA;AAEnC,IAAA,OAAO,IAAI,CAAA;AACb,CAAC;AAED,SAAS,UAAU,CAAC,MAAc,EAAA;AAChC,IAAA,OAAO,MAAM;AACV,SAAA,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC;AACtB,SAAA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC;AACrB,SAAA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC;AACrB,SAAA,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC;AACvB,SAAA,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;AAC5B,CAAC;AAED,SAAS,wBAAwB,CAAC,MAAe,EAAE,GAAW,EAAA;AAC5D,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAA;AACzB,IAAA,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAA;IAC7B,OAAO,CAAA,KAAA,EAAQ,UAAU,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAA,IAAA,CAAM,CAAA;AACjD,CAAC;AAED,SAAS,kBAAkB,CAAC,MAAe,EAAE,GAAW,EAAA;AACtD,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAA;IACzB,MAAM,SAAS,GAAG,aAAa,CAAA;AAC/B,IAAA,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAA;AAC3B,IAAA,MAAM,MAAM,GAAG,CAAA,UAAA,EAAa,KAAK,CAAM,GAAA,EAAA,KAAK,QAAQ,CAAA;AACpD,IAAA,OAAO,CAAe,YAAA,EAAA,SAAS,CAAK,EAAA,EAAA,MAAM,QAAQ,CAAA;AACpD,CAAC;AAED;;;;;;;;;AASE;AACI,SAAU,gBAAgB,CAAC,EAAc,EAAA;AAC7C,IAAA,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,aAAa,EAAE,gBAAgB,EAAE;QAC9D,GAAG,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,EAAE,cAAc,CAAC;AACtE,KAAA,CAAC,CAAA;AACJ,CAAC;AAED,SAAS,gBAAgB,CACvB,KAAiB,EACjB,SAAiB,EACjB,OAAe,EACf,MAAe,EAAA;IAEf,IAAI,aAAa,GAAG,KAAK,CAAA;AACzB,IAAA,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;IAC3D,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;;AAGjC,IAAA,IAAI,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC,SAAS,IAAI,CAAC,EAAE;AAClD,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;AAED,IAAA,IAAI,GAAG,GAAG,CAAC,GAAG,GAAG,EAAE;AACjB,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;IAED,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;AAExC,IAAA,IAAI,MAAM,KAAK,IAAI,UAAU;AAC3B,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;;IAGD,IAAI,GAAG,GAAG,GAAG,CAAA;IACb,GAAG,GAAG,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,MAAM,CAAC,CAAA;AAElC,IAAA,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAA;IAEnB,IAAI,GAAG,GAAG,CAAC,EAAE;AACX,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;AAED,IAAA,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;AACxC,IAAA,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;;AAGxC,IAAA,IAAI,MAAM,EAAE;AACV,QAAA,OAAO,IAAI,CAAA;AACZ,KAAA;;IAGD,IAAI,QAAQ,GAAG,SAAS,CAAA;IAExB,SAAS;AACP,QAAA,QAAQ,EAAE,CAAA;QACV,IAAI,QAAQ,IAAI,OAAO,EAAE;;;YAGvB,MAAK;AACN,SAAA;AAED,QAAA,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;AAC3D,QAAA,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;AAE5B,QAAA,IAAI,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,SAAS,EAAE;;;;YAIzD,MAAK;AACN,SAAA;QAED,IAAI,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,MAAM,EAAE;YACxC,SAAQ;AACT,SAAA;AAED,QAAA,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,SAAS,IAAI,CAAC,EAAE;;YAEjD,SAAQ;AACT,SAAA;QAED,GAAG,GAAG,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,MAAM,CAAC,CAAA;;AAGlC,QAAA,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE;YACnB,SAAQ;AACT,SAAA;;AAGD,QAAA,GAAG,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;QAE3B,IAAI,GAAG,GAAG,GAAG,EAAE;YACb,SAAQ;AACT,SAAA;QAED,aAAa,GAAG,IAAI,CAAA;;QAEpB,MAAK;AACN,KAAA;;AAGD,IAAA,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;AAE7B,IAAA,KAAK,CAAC,IAAI,GAAG,QAAQ,IAAI,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,CAAA;AAE/C,IAAA,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC,CAAA;AAC5C,IAAA,KAAK,CAAC,IAAI,GAAG,MAAM,CAAA;AACnB,IAAA,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC,SAAS,GAAG,CAAC,EAAE,QAAQ,EAAE,GAAG,EAAE,IAAI,CAAC,CAAA;AAClE,IAAA,KAAK,CAAC,MAAM,GAAG,MAAM,CAAA;IACrB,KAAK,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,IAAI,CAAC,CAAA;AAEnC,IAAA,OAAO,IAAI,CAAA;AACb;;;;"}