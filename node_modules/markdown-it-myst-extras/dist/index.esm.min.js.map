{"version":3,"file":"index.esm.min.js","sources":["../src/index.ts"],"sourcesContent":["import type MarkdownIt from \"markdown-it/lib\"\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.js\"\nimport type Token from \"markdown-it/lib/token.js\"\n\n/** Parse MyST targets (``(name)=``), blockquotes (``% comment``) and block breaks (``+++``).\n *\n * Adapted from: mdit_py_plugins/myst_blocks/index.py\n */\nexport function mystBlockPlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"blockquote\", \"myst_line_comment\", parse_line_comment, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_block_break\", parse_block_break, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.block.ruler.before(\"hr\", \"myst_target\", parse_target, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n  md.renderer.rules.myst_line_comment = render_myst_line_comment\n  md.renderer.rules.myst_target = render_myst_target\n}\n\nfunction parse_line_comment(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (state.src[pos] !== \"%\") {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  const token = state.push(\"myst_line_comment\", \"\", 0)\n  token.attrSet(\"class\", \"myst-line-comment\")\n  token.content = state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  token.markup = \"%\"\n\n  // search end of block while appending lines to `token.content`\n  let nextLine: number\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    maximum = state.eMarks[nextLine]\n    if (state.src[pos] !== \"%\") {\n      break\n    }\n    token.content += \"\\n\" + state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\") // rstrip\n  }\n  state.line = nextLine\n  token.map = [startLine, nextLine]\n\n  return true\n}\n\nfunction parse_block_break(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n  pos += 1\n\n  // Check block marker /* + */\n  if (marker !== 0x2b) {\n    return false\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  let cnt = 1\n  while (pos < maximum) {\n    const ch = state.src.charCodeAt(pos)\n    if (ch !== marker && !state.md.utils.isSpace(ch)) {\n      break\n    }\n    if (ch === marker) {\n      cnt += 1\n    }\n    pos += 1\n  }\n\n  if (cnt < 3) {\n    return false\n  }\n\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_block_break\", \"hr\", 0)\n  token.attrSet(\"class\", \"myst-block\")\n  token.content = state.src.slice(pos, maximum).trim()\n  token.map = [startLine, state.line]\n  token.markup = state.md.utils.fromCodePoint(marker).repeat(cnt)\n\n  return true\n}\n\nconst TARGET_PATTERN = /^\\((?<label>[a-zA-Z0-9|@<>*./_\\-+:]{1,100})\\)=\\s*$/\n\nfunction parse_target(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  const pos = state.bMarks[startLine] + state.tShift[startLine]\n  const maximum = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n  const match = TARGET_PATTERN.exec(state.src.slice(pos, maximum))\n  if (!match) {\n    return false\n  }\n  if (silent) {\n    return true\n  }\n\n  state.line = startLine + 1\n\n  const token = state.push(\"myst_target\", \"\", 0)\n  token.attrSet(\"class\", \"myst-target\")\n  token.content = match && match.groups ? match.groups[\"label\"] : \"\"\n  token.map = [startLine, state.line]\n\n  return true\n}\n\nfunction escapeHtml(unsafe: string) {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\")\n}\n\nfunction render_myst_line_comment(tokens: Token[], idx: number): string {\n  const token = tokens[idx]\n  const content = token.content\n  return `<!-- ${escapeHtml(content).trim()} -->`\n}\n\nfunction render_myst_target(tokens: Token[], idx: number) {\n  const token = tokens[idx]\n  const className = \"myst-target\"\n  const label = token.content\n  const target = `<a href=\"#${label}\">(${label})=</a>`\n  return `<div class=\"${className}\">${target}</div>`\n}\n\n/** Colon fence\n * This plugin directly mimics regular fences, but with `:` colons.\n *\n * Example:\n\n        :::name\n        contained text\n        :::\n *\n*/\nexport function colonFencePlugin(md: MarkdownIt): void {\n  md.block.ruler.before(\"fence\", \"colon_fence\", colon_fence_rule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n  })\n}\n\nfunction colon_fence_rule(\n  state: StateBlock,\n  startLine: number,\n  endLine: number,\n  silent: boolean\n): boolean {\n  let haveEndMarker = false\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false\n  }\n\n  if (pos + 3 > max) {\n    return false\n  }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x3a /* : */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) {\n    return false\n  }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) {\n    return true\n  }\n\n  // search end of block\n  let nextLine = startLine\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) {\n      continue\n    }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) {\n      continue\n    }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token = state.push(\"fence\", \"code\", 0)\n  token.info = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup = markup\n  token.map = [startLine, state.line]\n\n  return true\n}\n"],"names":["mystBlockPlugin","md","block","ruler","before","parse_line_comment","alt","parse_block_break","parse_target","renderer","rules","myst_line_comment","render_myst_line_comment","myst_target","render_myst_target","state","startLine","endLine","silent","pos","bMarks","tShift","maximum","eMarks","sCount","blkIndent","src","token","push","nextLine","attrSet","content","slice","replace","markup","line","map","marker","charCodeAt","cnt","ch","utils","isSpace","trim","fromCodePoint","repeat","TARGET_PATTERN","match","exec","groups","tokens","idx","unsafe","label","colonFencePlugin","colon_fence_rule","haveEndMarker","max","mem","skipChars","len","params","skipSpaces","info","getLines"],"mappings":"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"}