import { remove } from 'unist-util-remove';
import { selectAll } from 'unist-util-select';
import { copyNode } from './utils.js';
/**
 * Selects the block node(s) based on part (string) or tags (string[]).
 * If `part` is a string array, any of the parts will be treated equally.
 */
export function selectBlockParts(tree, part) {
    if (!part) {
        // Prevent an undefined, null or empty part comparison
        return [];
    }
    const blockParts = selectAll('block', tree).filter((block) => {
        const parts = typeof part === 'string' ? [part] : part;
        return parts
            .map((p) => {
            var _a, _b;
            return (((_a = block.data) === null || _a === void 0 ? void 0 : _a.part) === p ||
                (((_b = block.data) === null || _b === void 0 ? void 0 : _b.tags) && Array.isArray(block.data.tags) && block.data.tags.includes(p)));
        })
            .reduce((a, b) => a || b, false);
    });
    return blockParts;
}
/**
 * Returns a copy of the block parts and removes them from the tree.
 */
export function extractPart(tree, part, opts) {
    const partStrings = typeof part === 'string' ? [part] : part;
    const blockParts = selectBlockParts(tree, part);
    if (blockParts.length === 0)
        return undefined;
    const children = copyNode(blockParts).map((block) => {
        var _a;
        // Ensure the block always has the `part` defined, as it might be in the tags
        (_a = block.data) !== null && _a !== void 0 ? _a : (block.data = {});
        block.data.part = partStrings[0];
        if (block.data.tags &&
            Array.isArray(block.data.tags) &&
            block.data.tags.reduce((a, t) => a || partStrings.includes(t), false)) {
            block.data.tags = block.data.tags.filter((tag) => !partStrings.includes(tag));
            if (block.data.tags.length === 0) {
                delete block.data.tags;
            }
        }
        if (opts === null || opts === void 0 ? void 0 : opts.removePartData)
            delete block.data.part;
        // The default is to remove the visibility on the parts
        if (!(opts === null || opts === void 0 ? void 0 : opts.keepVisibility))
            delete block.visibility;
        return block;
    });
    const partsTree = { type: 'root', children };
    // Remove the block parts from the main document
    blockParts.forEach((block) => {
        block.type = '__delete__';
    });
    remove(tree, '__delete__');
    return partsTree;
}
