import { customAlphabet } from 'nanoid';
function addMessageInfo(message, info) {
    if (info === null || info === void 0 ? void 0 : info.note)
        message.note = info.note;
    if (info === null || info === void 0 ? void 0 : info.url)
        message.url = info.url;
    if (info === null || info === void 0 ? void 0 : info.ruleId)
        message.ruleId = info.ruleId;
    if (info === null || info === void 0 ? void 0 : info.fatal)
        message.fatal = true;
    return message;
}
export function fileError(file, message, opts) {
    return addMessageInfo(file.message(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), { ...opts, fatal: true });
}
export function fileWarn(file, message, opts) {
    return addMessageInfo(file.message(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), opts);
}
export function fileInfo(file, message, opts) {
    return addMessageInfo(file.info(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), opts);
}
const az = 'abcdefghijklmnopqrstuvwxyz';
const alpha = az + az.toUpperCase();
const numbers = '0123456789';
const nanoidAZ = customAlphabet(alpha, 1);
const nanoidAZ9 = customAlphabet(alpha + numbers, 9);
export function createId() {
    return nanoidAZ() + nanoidAZ9();
}
/**
 * https://github.com/syntax-tree/mdast#association
 * @param label A label field can be present.
 *        label is a string value: it works just like title on a link or a
 *        lang on code: character escapes and character references are parsed.
 * @returns { identifier, label, html_id }
 */
export function normalizeLabel(label) {
    if (!label)
        return undefined;
    const identifier = label
        .replace(/[\t\n\r ]+/g, ' ')
        .trim()
        .toLowerCase();
    const html_id = createHtmlId(identifier);
    return { identifier, label: label, html_id };
}
export function createHtmlId(identifier) {
    if (!identifier)
        return undefined;
    return identifier
        .toLowerCase()
        .replace(/[^a-z0-9-]/g, '-') // Remove any fancy characters
        .replace(/^([0-9-])/, 'id-$1') // Ensure that the id starts with a letter
        .replace(/-[-]+/g, '-') // Replace repeated `-`s
        .replace(/(?:^[-]+)|(?:[-]+$)/g, ''); // Remove repeated `-`s at the start or the end
}
/**
 * Helper function for recursively lifting children
 */
function getNodeOrLiftedChildren(node, removeType) {
    if (!node.children)
        return [node];
    const children = node.children.map((child) => getNodeOrLiftedChildren(child, removeType)).flat();
    if (node.type === removeType) {
        // There are some checks in unist that look like `'children' in node`
        // all children must be deleted, and not a key on the object
        if (node && node.children == null)
            delete node.children;
        return children;
    }
    node.children = children;
    return [node];
}
/**
 * Eliminate all parent nodes in `tree` of type `removeType`; children of eliminated nodes are moved up to it's parent
 *
 * Nodes of `removeType` will remain if:
 * - they are the root of `tree`
 * - their children are undefined
 */
export function liftChildren(tree, removeType) {
    if (!tree.children)
        return;
    tree.children = tree.children.map((child) => getNodeOrLiftedChildren(child, removeType)).flat();
}
export function setTextAsChild(node, text) {
    node.children = [{ type: 'text', value: text }];
}
/**
 * Renders a textual representation of one or more nodes
 * by concatenating all children that have a text representation.
 * @param content The node or nodes to provide as input.
 * @returns A string. An empty string is returned in case no
 * textual representation could be extracted.
 */
export function toText(content) {
    if (!content)
        return '';
    if (!Array.isArray(content))
        return toText([content]);
    return content
        .map((n) => {
        if (!n || typeof n === 'string')
            return n || '';
        if ('value' in n)
            return n.value;
        if ('children' in n && n.children)
            return toText(n.children);
        return '';
    })
        .join('');
}
export function copyNode(node) {
    return JSON.parse(JSON.stringify(node));
}
export function mergeTextNodes(node) {
    var _a;
    const children = (_a = node.children) === null || _a === void 0 ? void 0 : _a.reduce((c, n) => {
        var _a;
        if ((n === null || n === void 0 ? void 0 : n.type) !== 'text') {
            c.push(mergeTextNodes(n));
            return c;
        }
        const last = c[c.length - 1];
        if ((last === null || last === void 0 ? void 0 : last.type) !== 'text') {
            c.push(n);
            return c;
        }
        if ((_a = n.position) === null || _a === void 0 ? void 0 : _a.end) {
            if (!last.position)
                last.position = {};
            last.position.end = n.position.end;
        }
        if (!last.value)
            last.value = '';
        if (n.value)
            last.value += n.value;
        return c;
    }, []);
    if (children)
        node.children = children;
    return node;
}
export function admonitionKindToTitle(kind) {
    const transform = {
        attention: 'Attention',
        caution: 'Caution',
        danger: 'Danger',
        error: 'Error',
        important: 'Important',
        hint: 'Hint',
        note: 'Note',
        seealso: 'See Also',
        tip: 'Tip',
        warning: 'Warning',
    };
    return transform[kind] || `Unknown Admonition "${kind}"`;
}
export function writeTexLabelledComment(title, commands, commentLength) {
    if (!commands || (commands === null || commands === void 0 ? void 0 : commands.length) === 0)
        return '';
    const len = (commentLength - title.length - 4) / 2;
    const start = ''.padEnd(Math.ceil(len), '%');
    const end = ''.padEnd(Math.floor(len), '%');
    const titleBlock = `${start}  ${title}  ${end}\n`;
    return `${titleBlock}${commands.join('\n')}\n`;
}
