/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Myst syntax tree built on existing mdast schemas
 */
export type Root = {
  type?: "root";
  /**
   * Top-level children of myst document
   */
  children?: (Block | BlockBreak | FlowContent)[] | ListContent[] | PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & Parent;
/**
 * Top-level content blocks or cells the myst document, delimited by BlockBreaks
 */
export type Block = {
  type?: "block";
  /**
   * block metadata from preceding break; conventionally, a stringified JSON dictionary but may be any arbitrary string
   */
  meta?: string;
  /**
   * Top-level children of myst document
   */
  children?: FlowContent[] | ListContent[] | PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
export type FlowContent =
  | Paragraph
  | Definition
  | Heading
  | ThematicBreak
  | Blockquote
  | List
  | HTML
  | Code
  | Comment
  | Target
  | Directive
  | Admonition
  | Container
  | Math
  | Table
  | FootnoteDefinition;
export type Paragraph = {
  type?: "paragraph";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
export type PhrasingContent =
  | StaticPhrasingContent
  | Emphasis
  | Strong
  | Link
  | LinkReference
  | Subscript
  | Superscript
  | Underline
  | Abbreviation
  | CrossReference
  | FootnoteReference;
export type StaticPhrasingContent =
  | Text
  | HTML
  | EmphasisStatic
  | StrongStatic
  | InlineCode
  | Break
  | Image
  | ImageReference
  | Role
  | SubscriptStatic
  | SuperscriptStatic
  | UnderlineStatic
  | InlineMath;
export type Text = {
  type?: "text";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * The value of the node
   */
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Fragment of raw HTML - does not need to be valid or complete
 */
export type HTML = {
  type?: "html";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * The value of the node
   */
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Stressed, italicized content, with static children; used when parent node requires static content
 */
export type EmphasisStatic = {
  type?: "emphasis";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Important, serious, urgent, bold content, with static children; used when parent node requires static content
 */
export type StrongStatic = {
  type?: "strong";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Fragment of code
 */
export type InlineCode = {
  type?: "inlineCode";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * The value of the node
   */
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Line break
 */
export type Break = {
  type?: "break";
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
/**
 * Image hyperlink
 */
export type Image = {
  type?: "image";
  /**
   * user-defined class for image
   */
  class?: string;
  /**
   * image width in pixels or percentage
   */
  width?: string;
  align?: "left" | "center" | "right";
  url?: unknown;
  title?: unknown;
  alt?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * A Uniform Resource Locator (URL) to an external resource or link.
   */
  url: string;
  /**
   * advisory information, e.g. for a tooltip
   */
  title?: string;
} & {
  /**
   * field describing the image
   */
  alt?: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
/**
 * Image through association
 */
export type ImageReference = {
  type?: "imageReference";
  referenceType?: unknown;
  identifier?: unknown;
  label?: unknown;
  alt?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * explicitness of the reference:
   * `shortcut` - reference is implicit, identifier inferred
   * `collapsed` - reference explicit, identifier inferred
   * `full` - reference explicit, identifier explicit
   */
  referenceType: "shortcut" | "collapsed" | "full";
} & ({
    identifier: unknown;
  } & {
    /**
     * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
     */
    identifier?: string;
    /**
     * node label; character escapes and references are parsed; may be normalized to a unique identifier
     */
    label?: string;
  }) & {
    /**
     * field describing the image
     */
    alt?: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  };
/**
 * Custom in-line behavior
 */
export type Role = {
  type?: "mystRole";
  name: string;
  /**
   * content of the directive
   */
  value?: string;
  /**
   * parsed role content
   */
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
/**
 * Subscript content, with static children; used when parent node requires static content
 */
export type SubscriptStatic = {
  type?: "subscript";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Superscript content, with static children; used when parent node requires static content
 */
export type SuperscriptStatic = {
  type?: "superscript";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Underline content, with static children; used when parent node requires static content
 */
export type UnderlineStatic = {
  type?: "underline";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Fragment of math, similar to InlineCode, using role {math}
 */
export type InlineMath = {
  type?: "inlineMath";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * The value of the node
   */
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Stressed, italicized content
 */
export type Emphasis = {
  type?: "emphasis";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Important, serious, urgent, bold content
 */
export type Strong = {
  type?: "strong";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Hyperlink
 */
export type Link = {
  type?: "link";
  children?: StaticPhrasingContent[];
  url?: unknown;
  title?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * A Uniform Resource Locator (URL) to an external resource or link.
   */
  url: string;
  /**
   * advisory information, e.g. for a tooltip
   */
  title?: string;
} & ({
    /**
     * List of children nodes
     */
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  });
/**
 * Hyperlink through association
 */
export type LinkReference = {
  type?: "linkReference";
  children?: StaticPhrasingContent[];
  referenceType?: unknown;
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * explicitness of the reference:
   * `shortcut` - reference is implicit, identifier inferred
   * `collapsed` - reference explicit, identifier inferred
   * `full` - reference explicit, identifier explicit
   */
  referenceType: "shortcut" | "collapsed" | "full";
} & ({
    identifier: unknown;
  } & {
    /**
     * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
     */
    identifier?: string;
    /**
     * node label; character escapes and references are parsed; may be normalized to a unique identifier
     */
    label?: string;
  }) &
  ({
    /**
     * List of children nodes
     */
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  });
/**
 * Subscript content, using role {subscript}
 */
export type Subscript = {
  type?: "subscript";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Superscript content, using role {superscript}
 */
export type Superscript = {
  type?: "superscript";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Underline content, using role {underline}
 */
export type Underline = {
  type?: "underline";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Abbreviation node described by title
 */
export type Abbreviation = {
  type?: "abbreviation";
  /**
   * abbreviated value
   */
  children?: StaticPhrasingContent[];
  /**
   * advisory information for the abbreviation
   */
  title?: string;
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * In-line reference to an associated node
 */
export type CrossReference = {
  type?: "crossReference";
  /**
   * Indicates if the references should be numbered.
   * ```{warning}
   * The `kind` was based on docutils and is subject to change as we improve the `crossReference` experience.
   * ```
   */
  kind?: "eq" | "numref" | "ref";
  /**
   * Children of the crossReference, can include text with "%s" or "{number}" and enumerated references will be filled in.
   */
  children?: StaticPhrasingContent[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  };
/**
 * Inline reference to footnote
 */
export type FootnoteReference = {
  type?: "footnoteReference";
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  };
/**
 * Reference to a url resource
 */
export type Definition = {
  type?: "definition";
  identifier?: unknown;
  label?: unknown;
  url?: unknown;
  title?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) & {
    /**
     * A Uniform Resource Locator (URL) to an external resource or link.
     */
    url: string;
    /**
     * advisory information, e.g. for a tooltip
     */
    title?: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  };
export type Heading = {
  type?: "heading";
  depth: number;
  /**
   * count this heading for numbering based on kind, e.g. Section 2.4.1
   */
  enumerated?: boolean;
  /**
   * resolved enumerated value for this heading
   */
  enumerator?: string;
  children?: PhrasingContent[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
}) & {
    /**
     * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
     */
    identifier?: string;
    /**
     * node label; character escapes and references are parsed; may be normalized to a unique identifier
     */
    label?: string;
  };
export type ThematicBreak = {
  type?: "thematicBreak";
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
export type Blockquote = {
  type?: "blockquote";
  children?: FlowContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
export type List = {
  type?: "list";
  /**
   * Is item order important or not?
   */
  ordered?: boolean;
  /**
   * Starting number of ordered list
   */
  start?: number;
  /**
   * One or more children are separated with a blank line from others
   */
  spread?: boolean;
  children?: ListContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
export type ListContent = ListItem;
export type ListItem = {
  type?: "listItem";
  /**
   * One or more children are separated with a blank line from others
   */
  spread?: boolean;
  children?: (PhrasingContent | FlowContent)[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Block of preformatted text
 */
export type Code = {
  type?: "code";
  /**
   * language of the code
   */
  lang?: string;
  /**
   * custom information relating to the node
   */
  meta?: string;
  /**
   * user-defined class for code block
   */
  class?: string;
  showLineNumbers?: boolean;
  startingLineNumber?: number;
  emphasizeLines?: number[];
  identifier?: unknown;
  label?: unknown;
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & {} & {} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
} & ({
    /**
     * The value of the node
     */
    value: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  });
/**
 * Comment nodes for comments present in myst but ignored upon render
 */
export type Comment = {
  type?: "mystComment";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * The value of the node
   */
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Target node - provides identifier/label for the following node
 */
export type Target = {
  type?: "mystTarget";
  /**
   * unresolved target label
   */
  label?: string;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
/**
 * Content block with predefined behavior
 */
export type Directive = {
  type?: "mystDirective";
  name: string;
  args?: string;
  options?: {
    [k: string]: unknown;
  };
  /**
   * body of the directive, excluding options
   */
  value?: string;
  /**
   * parsed directive content
   */
  children?: (FlowContent | PhrasingContent)[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
/**
 * Admonition node for drawing attention to text, separate from the neighboring content
 */
export type Admonition = {
  type?: "admonition";
  /**
   * kind of admonition, to determine styling
   */
  kind?: "attention" | "caution" | "danger" | "error" | "hint" | "important" | "note" | "seealso" | "tip" | "warning";
  /**
   * admonition class info to override kind
   */
  class?: string;
  /**
   * An optional `admonitionTitle` followed by the admonitions content.
   */
  children?: (AdmonitionTitle | FlowContent)[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
/**
 * Custom title for admonition, replaces kind as title
 */
export type AdmonitionTitle = {
  type?: "admonitionTitle";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Top-level container node to provide association and numbering to child content
 */
export type Container = {
  type?: "container";
  /**
   * kind of container contents
   */
  kind: "figure" | "table";
  /**
   * any custom class information
   */
  class?: string;
  /**
   * count this container for numbering based on kind, e.g. Figure 1a
   */
  enumerated?: boolean;
  /**
   * resolved enumerated value for this container
   */
  enumerator?: string;
  children?: (Caption | Legend | Image | Table)[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & {} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
} & ({
    /**
     * List of children nodes
     */
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  });
/**
 * Caption for container content
 */
export type Caption = {
  type?: "caption";
  children?: FlowContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Legend for container content
 */
export type Legend = {
  type?: "legend";
  children?: FlowContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Two-dimensional table data
 */
export type Table = {
  type?: "table";
  align?: "left" | "center" | "right";
  children?: TableRow[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * One row of table containing cells
 */
export type TableRow = {
  type?: "tableRow";
  children?: TableCell[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * One cell of table
 */
export type TableCell = {
  type?: "tableCell";
  header?: boolean;
  /**
   * alignment of content within cell
   */
  align?: "left" | "center" | "right";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
});
/**
 * Math node for presenting numbered equations
 */
export type Math = {
  type?: "math";
  /**
   * count this math block for numbering based on kind, e.g. See equation (1a)
   */
  enumerated?: boolean;
  /**
   * resolved enumerated value for this math block
   */
  enumerator?: string;
  identifier?: unknown;
  label?: unknown;
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
} & ({
    /**
     * The value of the node
     */
    value: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  });
/**
 * Rich footnote content associated with footnote reference
 */
export type FootnoteDefinition = {
  type?: "footnoteDefinition";
  children?: FlowContent[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) &
  ({
    /**
     * List of children nodes
     */
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number[];
    };
  });
/**
 * Top-level break in the myst document, breaking it into Blocks
 */
export type BlockBreak = {
  type?: "blockBreak";
  /**
   * Block metadata. Conventionally this is a stringified JSON dictionary but it may be any arbitrary string.
   */
  meta?: string;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};
/**
 * Basic node with required node children
 */
export type Parent = {
  /**
   * List of children nodes
   */
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
};

/**
 * Base node object, based on the [unist](https://github.com/syntax-tree/unist) syntax tree.
 */
export interface Node {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number[];
  };
}
