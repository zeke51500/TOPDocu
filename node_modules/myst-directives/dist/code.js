import { nanoid } from 'nanoid';
import yaml from 'js-yaml';
import { fileError, fileWarn, normalizeLabel, RuleId } from 'myst-common';
import { select } from 'unist-util-select';
function parseEmphasizeLines(emphasizeLinesString) {
    if (!emphasizeLinesString)
        return undefined;
    const emphasizeLines = emphasizeLinesString === null || emphasizeLinesString === void 0 ? void 0 : emphasizeLinesString.split(',').map((val) => Number(val.trim())).filter((val) => Number.isInteger(val));
    return emphasizeLines;
}
/** This function parses both sphinx and RST code-block options */
export function getCodeBlockOptions(data, vfile, defaultFilename) {
    var _a;
    const { options, node } = data;
    if ((options === null || options === void 0 ? void 0 : options['lineno-start']) != null && (options === null || options === void 0 ? void 0 : options['number-lines']) != null) {
        fileWarn(vfile, 'Cannot use both "lineno-start" and "number-lines"', {
            node: (_a = select('mystDirectiveOption[name="number-lines"]', node)) !== null && _a !== void 0 ? _a : node,
            source: 'code-block:options',
            ruleId: RuleId.directiveOptionsCorrect,
        });
    }
    const emphasizeLines = parseEmphasizeLines(options === null || options === void 0 ? void 0 : options['emphasize-lines']);
    const numberLines = options === null || options === void 0 ? void 0 : options['number-lines'];
    // Only include this in mdast if it is `true`
    const showLineNumbers = (options === null || options === void 0 ? void 0 : options.linenos) || (options === null || options === void 0 ? void 0 : options['lineno-start']) || (options === null || options === void 0 ? void 0 : options['lineno-match']) || numberLines
        ? true
        : undefined;
    let startingLineNumber = numberLines != null && numberLines > 1 ? numberLines : options === null || options === void 0 ? void 0 : options['lineno-start'];
    if (options === null || options === void 0 ? void 0 : options['lineno-match']) {
        startingLineNumber = 'match';
    }
    else if (startingLineNumber == null || startingLineNumber <= 1) {
        startingLineNumber = undefined;
    }
    let filename = options === null || options === void 0 ? void 0 : options['filename'];
    if ((filename === null || filename === void 0 ? void 0 : filename.toLowerCase()) === 'false') {
        filename = undefined;
    }
    else if (!filename && defaultFilename) {
        filename = defaultFilename;
    }
    return {
        emphasizeLines,
        showLineNumbers,
        startingLineNumber,
        filename,
    };
}
export const CODE_DIRECTIVE_OPTIONS = {
    caption: {
        type: 'myst',
        doc: 'A parsed caption for the code block.',
    },
    linenos: {
        type: Boolean,
        doc: 'Show line numbers',
    },
    'lineno-start': {
        type: Number,
        doc: 'Start line numbering from a particular value, default is 1. If present, line numbering is activated.',
    },
    'number-lines': {
        type: Number,
        doc: 'Alternative for "lineno-start", turns on line numbering and can be an integer that is the start of the line numbering.',
    },
    'emphasize-lines': {
        type: String,
        doc: 'Emphasize particular lines (comma-separated numbers), e.g. "3,5"',
    },
    filename: {
        type: String,
        doc: 'Show the filename in addition to the rendered code. The `include` directive will use the filename by default, to turn off this default set the filename to `false`.',
    },
    // dedent: {
    //   type: Number,
    //   doc: 'Strip indentation characters from the code block',
    // },
    // force: {
    //   type: Boolean,
    //   doc: 'Ignore minor errors on highlighting',
    // },
};
export const codeDirective = {
    name: 'code',
    doc: 'A code-block environment with a language as the argument, and options for highlighting, showing line numbers, and an optional filename.',
    alias: ['code-block', 'sourcecode'],
    arg: {
        type: String,
        doc: 'Code language, for example `python` or `typescript`',
    },
    options: {
        label: {
            type: String,
            alias: ['name'],
        },
        class: {
            type: String,
            // class_option: list of strings?
        },
        ...CODE_DIRECTIVE_OPTIONS,
    },
    body: {
        type: String,
        doc: 'The raw code to display for the code block.',
    },
    run(data, vfile) {
        var _a, _b, _c;
        const { label, identifier } = normalizeLabel((_a = data.options) === null || _a === void 0 ? void 0 : _a.label) || {};
        const opts = getCodeBlockOptions(data, vfile);
        const code = {
            type: 'code',
            lang: data.arg,
            class: (_b = data.options) === null || _b === void 0 ? void 0 : _b.class,
            ...opts,
            value: data.body,
        };
        if (!((_c = data.options) === null || _c === void 0 ? void 0 : _c.caption)) {
            code.label = label;
            code.identifier = identifier;
            return [code];
        }
        const caption = {
            type: 'caption',
            children: [
                {
                    type: 'paragraph',
                    children: data.options.caption,
                },
            ],
        };
        const container = {
            type: 'container',
            kind: 'code',
            label,
            identifier,
            children: [code, caption],
        };
        return [container];
    },
};
export const codeCellDirective = {
    name: 'code-cell',
    arg: {
        type: String,
    },
    options: {
        tags: {
            type: String,
        },
    },
    body: {
        type: String,
    },
    run(data, vfile) {
        var _a, _b, _c, _d, _e;
        const code = {
            type: 'code',
            lang: data.arg,
            executable: true,
            value: ((_a = data.body) !== null && _a !== void 0 ? _a : ''),
        };
        let tags;
        // TODO: this validation should be done in a different place
        // For example, specifying that the attribute is YAML,
        // and providing a custom validation on the option.
        if (typeof ((_b = data.options) === null || _b === void 0 ? void 0 : _b.tags) === 'string') {
            try {
                tags = yaml.load(data.options.tags);
            }
            catch (error) {
                fileError(vfile, 'Could not load tags for code-cell directive', {
                    node: (_c = select('mystDirectiveOption[name="tags"]', data.node)) !== null && _c !== void 0 ? _c : data.node,
                    source: 'code-cell:tags',
                    ruleId: RuleId.directiveOptionsCorrect,
                });
            }
        }
        else if (((_d = data.options) === null || _d === void 0 ? void 0 : _d.tags) && Array.isArray(data.options.tags)) {
            // if the options are loaded directly as yaml
            tags = data.options.tags;
        }
        if (tags && Array.isArray(tags) && tags.every((t) => typeof t === 'string')) {
            if (tags && tags.length > 0) {
                code.data = { tags: tags.map((t) => t.trim()) };
            }
        }
        else if (tags) {
            fileWarn(vfile, 'tags in code-cell directive must be a list of strings', {
                node: (_e = select('mystDirectiveOption[name="tags"]', data.node)) !== null && _e !== void 0 ? _e : data.node,
                source: 'code-cell:tags',
                ruleId: RuleId.directiveOptionsCorrect,
            });
        }
        const output = {
            type: 'output',
            id: nanoid(),
            data: [],
        };
        const block = {
            type: 'block',
            meta: undefined,
            children: [code, output],
            data: {
                type: 'notebook-code',
            },
        };
        return [block];
    },
};
