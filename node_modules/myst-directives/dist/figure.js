import { normalizeLabel } from 'myst-common';
export const figureDirective = {
    name: 'figure',
    arg: {
        type: String,
        doc: 'The filename of an image (e.g. `my-fig.png`), or an ID of a Jupyter Notebook cell (e.g. `#my-cell`).',
    },
    options: {
        label: {
            type: String,
            alias: ['name'],
        },
        class: {
            type: String,
            alias: ['figclass'],
            doc: `CSS classes to add to your figure. Special classes include:

- \`full-width\`: changes the figure environment to cover two columns in LaTeX`,
        },
        height: {
            type: String,
            doc: 'The figure height, in CSS units, for example `4em` or `300px`.',
            alias: ['h'],
        },
        width: {
            type: String,
            // TODO: validate that this is a CSS width
            alias: ['w', 'figwidth'],
            doc: 'The figure width, in CSS units, for example `50%` or `300px`.',
        },
        alt: {
            type: String,
            doc: 'Alternative text for the image',
        },
        // scale: {
        //   type: Number,
        // },
        // target: {
        //   type: String,
        // },
        align: {
            type: String,
            doc: 'The alignment of the image in the figure. Choose one of `left`, `center` or `right`',
            // TODO: this is not implemented below
            // choice(["left", "center", "right"])
        },
        'remove-input': {
            type: Boolean,
            doc: 'If the argument is a notebook cell, use this flag to remove the input code from the cell.',
        },
        'remove-output': {
            type: Boolean,
            doc: 'If the argument is a notebook cell, use this flag to remove the output from the cell.',
        },
        placeholder: {
            type: String,
            doc: 'A placeholder image when using a notebook cell as the figure contents. This will be shown in place of the Jupyter output until an execution environment is attached. It will also be used in static outputs, such as a PDF output.',
        },
        'no-subfigures': {
            type: Boolean,
            doc: 'Disallow implicit subfigure creation from child nodes',
            alias: ['no-subfig', 'no-subfigure'],
        },
        kind: {
            type: String,
            doc: 'Override the figures "kind", which changes the enumeration to start counting independently for that kind. For example, `kind: "example"`. The default enumeration and referencing will be the capitalized `kind` followed by a number (e.g. "Example 1").',
        },
    },
    body: {
        type: 'myst',
        doc: 'If an argument is provided to the figure directive, the body will be the figure caption. You may also omit the figure directive argument and provide images in the body of the figure, these will be parsed into sub figures.',
    },
    run(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const children = [];
        if (data.arg) {
            children.push({
                type: 'image',
                url: data.arg,
                alt: (_a = data.options) === null || _a === void 0 ? void 0 : _a.alt,
                width: (_b = data.options) === null || _b === void 0 ? void 0 : _b.width,
                height: (_c = data.options) === null || _c === void 0 ? void 0 : _c.height,
                align: (_d = data.options) === null || _d === void 0 ? void 0 : _d.align,
                // These will pass through if the node is converted to an embed node in the image transform
                'remove-input': (_e = data.options) === null || _e === void 0 ? void 0 : _e['remove-input'],
                'remove-output': (_f = data.options) === null || _f === void 0 ? void 0 : _f['remove-output'],
            });
        }
        if ((_g = data.options) === null || _g === void 0 ? void 0 : _g.placeholder) {
            children.push({
                type: 'image',
                placeholder: true,
                url: data.options.placeholder,
                alt: (_h = data.options) === null || _h === void 0 ? void 0 : _h.alt,
                width: (_j = data.options) === null || _j === void 0 ? void 0 : _j.width,
                height: (_k = data.options) === null || _k === void 0 ? void 0 : _k.height,
                align: (_l = data.options) === null || _l === void 0 ? void 0 : _l.align,
            });
        }
        if (data.body) {
            children.push(...data.body);
        }
        const { label, identifier } = normalizeLabel((_m = data.options) === null || _m === void 0 ? void 0 : _m.label) || {};
        const container = {
            type: 'container',
            kind: ((_o = data.options) === null || _o === void 0 ? void 0 : _o.kind) || 'figure',
            identifier,
            label,
            class: (_p = data.options) === null || _p === void 0 ? void 0 : _p.class,
            children,
        };
        if ((_q = data.options) === null || _q === void 0 ? void 0 : _q['no-subfigures']) {
            container.noSubcontainers = true;
        }
        return [container];
    },
};
