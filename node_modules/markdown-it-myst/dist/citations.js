/**
 * @license
 * citations.js file is adapted from `markdown-it-citations` (Sept 2023)
 * MIT License - Martin Ring <@martinring>
 * https://github.com/martinring/markdown-it-citations
 */
export const citationsPlugin = (md) => {
    const regexes = {
        citation: /^([^^-]|[^^].+?)?(-)?@([\w][\w:.#$%&\-+?<>~/]*)(.+)?$/,
        // Only allow a short [suffix] for in text citations (e.g. 50 characters)
        inText: /^@((?:[\w|{][\w:.#$%&\-+?<>~/]*[\w|}])|\w)(\s*)(\[([^\]]{1,50})\])?/,
        allowedBefore: /^[^a-zA-Z.0-9]$/,
    };
    md.inline.ruler.after('emphasis', 'citation', (state, silent) => {
        // const max = state.posMax;
        const char = state.src.charCodeAt(state.pos);
        if (char == 0x40 /* @ */ &&
            (state.pos == 0 || regexes.allowedBefore.test(state.src.slice(state.pos - 1, state.pos)))) {
            // in-text
            const match = state.src.slice(state.pos).match(regexes.inText);
            if (match) {
                const citation = {
                    label: trimBraces(match[1]),
                    kind: 'narrative',
                };
                let token;
                if (!silent) {
                    token = state.push('cite', 'cite', 0);
                    token.meta = citation;
                    token.col = [state.pos];
                }
                if (match[3]) {
                    // The in-text citation is followed by [suffix]
                    // Another way to do this is to use `state.md.helpers.parseLinkLabel(state, suffixStart);`
                    const suffix = match[4];
                    citation.suffix = state.md.parseInline(suffix, state.env);
                    state.pos += match[0].length;
                    if (token) {
                        token.content = match[0];
                        token.col.push(state.pos);
                    }
                }
                else {
                    state.pos += match[0].length - match[2].length;
                    if (token) {
                        token.content = match[0];
                        token.col.push(state.pos);
                    }
                }
                return true;
            }
        }
        else if (char == 0x5b /* [ */) {
            const end = state.md.helpers.parseLinkLabel(state, state.pos);
            const charAfter = state.src.codePointAt(end + 1);
            if (end > 0 && charAfter != 0x28 && charAfter != 0x5b) {
                const str = state.src.slice(state.pos + 1, end);
                const parts = str.split(';').map((x) => x.match(regexes.citation));
                if (parts.indexOf(null) >= 0)
                    return false;
                let curCol = state.pos + 1;
                const cites = parts.map((x) => {
                    var _a, _b;
                    // remove the punctuation from the suffix if it exists
                    const suffix = x[4] ? x[4].trim().replace(/^,[\s]*/, '') : undefined;
                    const colEnd = curCol + x[0].length;
                    const meta = {
                        label: trimBraces(x[3]),
                        kind: 'parenthetical',
                        prefix: ((_a = x[1]) === null || _a === void 0 ? void 0 : _a.trim()) ? state.md.parseInline((_b = x[1]) === null || _b === void 0 ? void 0 : _b.trim(), state.env) : undefined,
                        suffix: suffix ? state.md.parseInline(suffix, state.env) : undefined,
                        partial: x[2] ? 'year' : undefined,
                        content: x[0].trim(),
                        col: [curCol, colEnd],
                    };
                    curCol = colEnd + 1;
                    return meta;
                });
                if (!silent) {
                    const token = state.push('cite_group_open', 'span', 1);
                    token.content = '[';
                    token.meta = { kind: 'parenthetical' };
                    cites.forEach((citation) => {
                        const { content, col, ...meta } = citation;
                        const cite = state.push('cite', 'cite', 0);
                        cite.content = content;
                        cite.col = col;
                        cite.meta = meta;
                    });
                    const close = state.push('cite_group_close', 'span', -1);
                    close.content = ']';
                }
                state.pos = end + 1;
                return true;
            }
            return false;
        }
        return false;
    });
};
function trimBraces(label) {
    return label.replace(/^\{(.*)\}$/, '$1');
}
