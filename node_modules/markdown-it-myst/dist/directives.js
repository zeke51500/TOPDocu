import yaml from 'js-yaml';
import { nestedPartToTokens } from './nestedParse.js';
import { stateError, stateWarn } from './utils.js';
const COLON_OPTION_REGEX = /^:(?<option>[^:\s]+?):(\s*(?<value>.*)){0,1}\s*$/;
/** Convert fences identified as directives to `directive` tokens */
function replaceFences(state) {
    for (const token of state.tokens) {
        if (token.type === 'fence' || token.type === 'colon_fence') {
            const match = token.info.match(/^\s*\{\s*([^}\s]+)\s*\}\s*(.*)$/);
            if (match) {
                token.type = 'directive';
                token.info = match[1].trim();
                token.meta = { arg: match[2] };
            }
        }
    }
    return true;
}
/** Run all directives, replacing the original token */
function runDirectives(state) {
    var _a;
    const finalTokens = [];
    for (const token of state.tokens) {
        if (token.type === 'directive') {
            try {
                const { info, map } = token;
                const arg = ((_a = token.meta.arg) === null || _a === void 0 ? void 0 : _a.trim()) || undefined;
                const content = parseDirectiveContent(token.content.trim() ? token.content.split(/\r?\n/) : [], info, state);
                const { body, options } = content;
                let { bodyOffset } = content;
                while (body.length && !body[0].trim()) {
                    body.shift();
                    bodyOffset++;
                }
                const bodyString = body.join('\n').trim();
                const directiveOpen = new state.Token('parsed_directive_open', '', 1);
                directiveOpen.info = info;
                directiveOpen.hidden = true;
                directiveOpen.content = bodyString;
                directiveOpen.map = map;
                directiveOpen.meta = {
                    arg,
                    options: simplifyDirectiveOptions(options),
                };
                const startLineNumber = map ? map[0] : 0;
                const argTokens = directiveArgToTokens(arg, startLineNumber, state);
                const optsTokens = directiveOptionsToTokens(options || [], startLineNumber + 1, state);
                const bodyTokens = directiveBodyToTokens(bodyString, startLineNumber + bodyOffset, state);
                const directiveClose = new state.Token('parsed_directive_close', '', -1);
                directiveClose.info = info;
                directiveClose.hidden = true;
                const newTokens = [
                    directiveOpen,
                    ...argTokens,
                    ...optsTokens,
                    ...bodyTokens,
                    directiveClose,
                ];
                finalTokens.push(...newTokens);
            }
            catch (err) {
                stateError(state, `Error parsing "${token.info}" directive: ${err.message}`);
                const errorToken = new state.Token('directive_error', '', 0);
                errorToken.content = token.content;
                errorToken.info = token.info;
                errorToken.meta = token.meta;
                errorToken.map = token.map;
                errorToken.meta.error_message = err.message;
                errorToken.meta.error_name = err.name;
                finalTokens.push(errorToken);
            }
        }
        else {
            finalTokens.push(token);
        }
    }
    state.tokens = finalTokens;
    return true;
}
function parseDirectiveContent(content, info, state) {
    var _a;
    let bodyOffset = 1;
    let yamlBlock = null;
    const newContent = [];
    if (content.length && content[0].trimEnd() === '---') {
        // options contained in YAML block, starting and ending with '---'
        bodyOffset++;
        yamlBlock = [];
        let foundDivider = false;
        for (const line of content.slice(1)) {
            if (line.trimEnd() === '---') {
                bodyOffset++;
                foundDivider = true;
                continue;
            }
            if (foundDivider) {
                newContent.push(line);
            }
            else {
                bodyOffset++;
                yamlBlock.push(line);
            }
        }
        try {
            const options = yaml.load(yamlBlock.join('\n'));
            if (options && typeof options === 'object') {
                return { body: newContent, options: Object.entries(options), bodyOffset };
            }
        }
        catch (err) {
            stateWarn(state, `Invalid YAML options in "${info}" directive: ${err.reason}`);
        }
    }
    else if (content.length && COLON_OPTION_REGEX.exec(content[0])) {
        const options = [];
        let foundDivider = false;
        for (const line of content) {
            if (!foundDivider && !COLON_OPTION_REGEX.exec(line)) {
                foundDivider = true;
                newContent.push(line);
                continue;
            }
            if (foundDivider) {
                newContent.push(line);
            }
            else {
                const match = COLON_OPTION_REGEX.exec(line);
                const { option, value } = (_a = match === null || match === void 0 ? void 0 : match.groups) !== null && _a !== void 0 ? _a : {};
                if (option)
                    options.push([option, value || 'true']);
                bodyOffset++;
            }
        }
        return { body: newContent, options, bodyOffset };
    }
    return { body: content, bodyOffset: 1 };
}
function directiveArgToTokens(arg, lineNumber, state) {
    return nestedPartToTokens('directive_arg', arg, lineNumber, state, 'run_directives', true);
}
function simplifyDirectiveOptions(options) {
    if (!options)
        return undefined;
    const simplified = {};
    options.forEach(([key, val]) => {
        if (simplified[key] !== undefined) {
            return;
        }
        else if (!isNaN(Number(val))) {
            simplified[key] = Number(val);
        }
        else if (typeof val === 'string' && val.toLowerCase() === 'true') {
            simplified[key] = true;
        }
        else if (typeof val === 'string' && val.toLowerCase() === 'false') {
            simplified[key] = false;
        }
        else {
            simplified[key] = val;
        }
    });
    return simplified;
}
function directiveOptionsToTokens(options, lineNumber, state) {
    const tokens = options.map(([key, value], index) => {
        // lineNumber mapping assumes each option is only one line;
        // not necessarily true for yaml options.
        const optTokens = nestedPartToTokens('directive_option', `${value}`, lineNumber + index, state, 'run_directives', true);
        if (optTokens.length) {
            optTokens[0].info = key;
            optTokens[0].content = value;
        }
        return optTokens;
    });
    return tokens.flat();
}
function directiveBodyToTokens(body, lineNumber, state) {
    return nestedPartToTokens('directive_body', body, lineNumber, state, 'run_directives', false);
}
export function directivePlugin(md) {
    md.core.ruler.after('block', 'fence_to_directive', replaceFences);
    md.core.ruler.after('fence_to_directive', 'run_directives', runDirectives);
    // fallback renderer for unhandled directives
    md.renderer.rules['directive'] = (tokens, idx) => {
        const token = tokens[idx];
        return `<aside class="directive-unhandled">\n<header><mark>${token.info}</mark><code> ${token.meta.arg}</code></header>\n<pre>${token.content}</pre></aside>\n`;
    };
    md.renderer.rules['directive_error'] = (tokens, idx) => {
        const token = tokens[idx];
        let content = '';
        if (token.content) {
            content = `\n---\n${token.content}`;
        }
        return `<aside class="directive-error">\n<header><mark>${token.info}</mark><code> ${token.meta.arg}</code></header>\n<pre>${token.meta.error_name}:\n${token.meta.error_message}\n${content}</pre></aside>\n`;
    };
}
