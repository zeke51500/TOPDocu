import type { KeyOptions, ValidationOptions } from './types.js';
export declare function defined<T = any>(val: T | null | undefined): val is T;
export declare function locationSuffix(opts: Partial<ValidationOptions>): string;
export declare function incrementOptions(property: string, opts: ValidationOptions): {
    property: string;
    location: string;
    messages: {
        errors?: {
            property: string;
            message: string;
        }[] | undefined;
        warnings?: {
            property: string;
            message: string;
        }[] | undefined;
    };
    file?: string | undefined;
    suppressWarnings?: boolean | undefined;
    suppressErrors?: boolean | undefined;
    warningLogFn?: ((message: string) => void) | undefined;
    errorLogFn?: ((message: string) => void) | undefined;
    escapeFn?: ((s: string) => string) | undefined;
};
export declare function validationError(message: string, opts: ValidationOptions): undefined;
export declare function validationWarning(message: string, opts: ValidationOptions): undefined;
/**
 * Validate value is boolean
 *
 * String 'true' and 'false' are coerced to booleans; error on any other value, including 1/0, 't'/'f', etc.
 */
export declare function validateBoolean(input: any, opts: ValidationOptions): any;
/**
 * Validate value is number
 *
 * Attempts to coerce inputs to number with Number(input)
 */
export declare function validateNumber(input: any, opts: {
    min?: number;
    max?: number;
    integer?: boolean;
} & ValidationOptions): number | undefined;
/**
 * Validates string value
 *
 * Ensures string length is less than `maxLength` and matches regular expression `regex`.
 * If `escapeFn` is provided, this will be applied to the output after other validation.
 */
export declare function validateString(input: any, opts: {
    coerceNumber?: boolean;
    maxLength?: number;
    regex?: string | RegExp;
} & ValidationOptions): string | undefined;
/**
 * Validate value is valid URL string of max length 2048
 *
 * If 'include' is provided, value must include it in the origin.
 */
export declare function validateUrl(input: any, opts: {
    includes?: string;
} & ValidationOptions): string | undefined;
export declare function validateSubdomain(input: string, opts: ValidationOptions): string | undefined;
/**
 * Validate value is valid email
 */
export declare function validateEmail(input: any, opts: ValidationOptions): string | undefined;
/**
 * Validate value against array of choices
 */
export declare function validateChoice<T>(input: any, opts: ValidationOptions & {
    choices: T[];
}): T | undefined;
/**
 * Validate value against enum
 *
 * Must provide enum object as both option 'enum' and the type variable.
 */
export declare function validateEnum<T>(input: any, opts: ValidationOptions & {
    enum: Record<string | number | symbol, any>;
}): T | undefined;
/**
 * Validate date string or object
 *
 * Uses javascript Date() constructor; any input to the constructor that returns
 * a valid date is valid input. This includes ISO 8601 formatted strings and
 * IETF timestamps are valid.
 */
export declare function validateDate(input: any, opts: ValidationOptions): string | undefined;
/**
 * Validates value is an object
 */
export declare function validateObject(input: any, opts: ValidationOptions): Record<string, any> | undefined;
/**
 * Validate an object has all required keys
 *
 * Returns new object with only required/optional keys
 */
export declare function validateKeys(input: Record<string, any>, keys: {
    required?: string[];
    optional?: string[];
    alias?: Record<string, string>;
}, opts: KeyOptions): Record<string, any> | undefined;
/**
 * Validates value is an object and has all required keys
 *
 * Returns new object with only required/optional keys
 */
export declare function validateObjectKeys(input: any, keys: {
    required?: string[];
    optional?: string[];
    alias?: Record<string, string>;
}, opts: KeyOptions): Record<string, any> | undefined;
/**
 * Validate value is a list
 */
export declare function validateList<T>(input: any, opts: ValidationOptions & {
    coerce?: boolean;
}, itemValidator: (item: any, index: number) => T | undefined): T[] | undefined;
/**
 * Copy 'base' object and fill any 'keys' that are missing with their values from 'filler'
 */
export declare function fillMissingKeys<T extends Record<string, any>>(base: T, filler: T, keys: (keyof T | string)[]): T;
export declare function filterKeys(value: Record<string, any>, keys: string[]): Record<string, any>;
//# sourceMappingURL=validators.d.ts.map