import { defined, incrementOptions, validateList, validateObject, validateString, validationError, } from 'simple-validators';
import { validateAffiliation } from '../affiliations/validators.js';
import { validateContributor } from '../contributors/validators.js';
import { validateFunding } from '../funding/validators.js';
import { validateAndStashObject } from '../utils/referenceStash.js';
import { validateGithubUrl } from '../utils/validators.js';
import { validateVenue } from '../venues/validators.js';
import { RESERVED_EXPORT_KEYS } from '../exports/validators.js';
export const SITE_FRONTMATTER_KEYS = [
    'title',
    'subtitle',
    'short_title',
    'description',
    'thumbnail',
    'thumbnailOptimized',
    'banner',
    'bannerOptimized',
    'authors',
    'contributors',
    'venue',
    'github',
    'keywords',
    'affiliations',
    'funding',
    'options',
];
export const FRONTMATTER_ALIASES = {
    author: 'authors',
    contributor: 'contributors',
    affiliation: 'affiliations',
    export: 'exports',
    jupyter: 'thebe',
    part: 'parts',
    ack: 'acknowledgments',
    acknowledgements: 'acknowledgments',
    availability: 'data_availability',
    plain_language_summary: 'summary',
    quote: 'epigraph',
    lay_summary: 'summary',
    image: 'thumbnail',
};
export function validateSiteFrontmatterKeys(value, opts) {
    var _a, _b, _c, _d, _e;
    const output = {};
    if (defined(value.title)) {
        output.title = validateString(value.title, incrementOptions('title', opts));
    }
    if (defined(value.description)) {
        output.description = validateString(value.description, incrementOptions('description', opts));
    }
    if (defined(value.short_title)) {
        output.short_title = validateString(value.short_title, incrementOptions('short_title', opts));
    }
    if (defined(value.subtitle)) {
        output.subtitle = validateString(value.subtitle, incrementOptions('subtitle', opts));
    }
    if (value.banner === null) {
        // It is possible for the banner to explicitly be null.
        // This means not to look to the images in a page.
        output.banner = null;
    }
    else if (defined(value.banner)) {
        output.banner = validateString(value.banner, incrementOptions('banner', opts));
    }
    if (defined(value.bannerOptimized)) {
        // No validation, this is expected to be set programmatically
        output.bannerOptimized = value.bannerOptimized;
    }
    const stash = {};
    if (defined(value.affiliations)) {
        const affiliationsOpts = incrementOptions('affiliations', opts);
        let affiliations = value.affiliations;
        if (typeof affiliations === 'string') {
            affiliations = affiliations.split(';').map((aff) => aff.trim());
        }
        validateList(affiliations, affiliationsOpts, (aff) => {
            return validateAndStashObject(aff, stash, 'affiliations', validateAffiliation, affiliationsOpts);
        });
    }
    if (defined(value.authors)) {
        stash.authorIds = validateList(value.authors, { coerce: true, ...incrementOptions('authors', opts) }, (author, index) => {
            return validateAndStashObject(author, stash, 'contributors', (v, o) => validateContributor(v, stash, o), incrementOptions(`authors.${index}`, opts));
        });
    }
    if (defined(value.contributors)) {
        // In addition to contributors defined here, additional contributors may be defined elsewhere
        // in the frontmatter (e.g. funding award investigator/recipient). These extra contributors
        // are combined with this list at the end of validation.
        validateList(value.contributors, { coerce: true, ...incrementOptions('contributors', opts) }, (contributor, index) => {
            return validateAndStashObject(contributor, stash, 'contributors', (v, o) => validateContributor(v, stash, o), incrementOptions(`contributors.${index}`, opts));
        });
    }
    if (defined(value.venue)) {
        output.venue = validateVenue(value.venue, incrementOptions('venue', opts));
    }
    if (defined(value.github)) {
        output.github = validateGithubUrl(value.github, incrementOptions('github', opts));
    }
    if (defined(value.keywords)) {
        let keywords = value.keywords;
        if (typeof keywords === 'string') {
            keywords = keywords.split(/[,;]/).map((k) => k.trim());
        }
        output.keywords = validateList(keywords, incrementOptions('keywords', opts), (word, ind) => {
            return validateString(word, incrementOptions(`keywords.${ind}`, opts));
        });
    }
    if (defined(value.funding)) {
        output.funding = validateList(value.funding, { coerce: true, ...incrementOptions('funding', opts) }, (fund, index) => {
            return validateFunding(fund, stash, incrementOptions(`funding.${index}`, opts));
        });
    }
    if (defined(value.options)) {
        const optionsOptions = incrementOptions('options', opts);
        const options = validateObject(value.options, optionsOptions);
        if (options) {
            Object.entries(options).forEach(([key, val]) => {
                var _a;
                if (RESERVED_EXPORT_KEYS.includes(key)) {
                    validationError(`options cannot include reserved key ${key}`, optionsOptions);
                }
                else {
                    ((_a = output.options) !== null && _a !== void 0 ? _a : (output.options = {}))[key] = val;
                }
            });
        }
    }
    // Contributor resolution should happen last
    const stashContribAuthors = (_a = stash.contributors) === null || _a === void 0 ? void 0 : _a.filter((contrib) => { var _a; return (_a = stash.authorIds) === null || _a === void 0 ? void 0 : _a.includes(contrib.id); });
    const stashContribNonAuthors = (_b = stash.contributors) === null || _b === void 0 ? void 0 : _b.filter((contrib) => { var _a; return !((_a = stash.authorIds) === null || _a === void 0 ? void 0 : _a.includes(contrib.id)); });
    if (stashContribAuthors === null || stashContribAuthors === void 0 ? void 0 : stashContribAuthors.length) {
        output.authors = stashContribAuthors;
        // Ensure there is a corresponding author if an email is provided
        const corresponding = (_c = output.authors) === null || _c === void 0 ? void 0 : _c.find((a) => a.corresponding !== undefined);
        const email = (_d = output.authors) === null || _d === void 0 ? void 0 : _d.find((a) => a.email);
        if (!corresponding && email) {
            email.corresponding = true;
        }
    }
    if (stashContribNonAuthors === null || stashContribNonAuthors === void 0 ? void 0 : stashContribNonAuthors.length) {
        output.contributors = stashContribNonAuthors;
    }
    if ((_e = stash.affiliations) === null || _e === void 0 ? void 0 : _e.length) {
        output.affiliations = stash.affiliations;
    }
    return output;
}
