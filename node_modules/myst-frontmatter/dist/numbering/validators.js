import { defined, fillMissingKeys, incrementOptions, validateBoolean, validateNumber, validateObjectKeys, validateString, validationWarning, } from 'simple-validators';
export const NUMBERING_OPTIONS = ['enumerator', 'all', 'headings'];
const HEADING_KEYS = ['heading_1', 'heading_2', 'heading_3', 'heading_4', 'heading_5', 'heading_6'];
export const NUMBERING_KEYS = [
    'figure',
    'subfigure',
    'equation',
    'subequation',
    'table',
    'code',
    ...HEADING_KEYS,
];
const NUMBERING_ITEM_KEYS = ['enabled', 'start', 'template'];
export const NUMBERING_ALIAS = {
    sections: 'headings',
    h1: 'heading_1',
    h2: 'heading_2',
    h3: 'heading_3',
    h4: 'heading_4',
    h5: 'heading_5',
    h6: 'heading_6',
    heading1: 'heading_1',
    heading2: 'heading_2',
    heading3: 'heading_3',
    heading4: 'heading_4',
    heading5: 'heading_5',
    heading6: 'heading_6',
};
function isBoolean(input) {
    if (typeof input === 'string') {
        return ['true', 'false'].includes(input.toLowerCase());
    }
    return typeof input === 'boolean';
}
/**
 * Validate value for each numbering entry
 *
 * Value may be:
 * - boolean, to simply enable/disable numbering
 * - number, to indicate the starting number
 * - string, to define the cross-reference template
 *   (e.g. 'Fig. %s' to get "Fig. 1" instead of "Figure 1" in your document)
 * - An object with any of enabled/start/template - specifying the above types
 *   will coerce to this object
 */
export function validateNumberingItem(input, opts) {
    var _a, _b;
    if (isBoolean(input)) {
        input = { enabled: input };
    }
    else if (typeof input === 'number') {
        input = { start: input };
    }
    else if (typeof input === 'string') {
        input = { template: input };
    }
    const value = validateObjectKeys(input, { optional: NUMBERING_ITEM_KEYS }, opts);
    if (value === undefined)
        return undefined;
    const output = {};
    if (defined(value.enabled)) {
        const enabled = validateBoolean(value.enabled, incrementOptions('enabled', opts));
        if (defined(enabled))
            output.enabled = enabled;
    }
    if (defined(value.start)) {
        const start = validateNumber(value.start, {
            ...incrementOptions('start', opts),
            integer: true,
            min: 1,
        });
        if (start) {
            output.start = start;
            output.enabled = (_a = output.enabled) !== null && _a !== void 0 ? _a : true;
        }
    }
    if (defined(value.template)) {
        const template = validateString(value.template, incrementOptions('template', opts));
        if (defined(template)) {
            output.template = template;
            output.enabled = (_b = output.enabled) !== null && _b !== void 0 ? _b : true;
        }
    }
    if (Object.keys(output).length === 0)
        return undefined;
    return output;
}
/**
 * Validate Numbering object
 */
export function validateNumbering(input, opts) {
    var _a, _b, _c, _d;
    if (isBoolean(input)) {
        input = { all: input };
    }
    const value = validateObjectKeys(input, { optional: [...NUMBERING_KEYS, ...NUMBERING_OPTIONS], alias: NUMBERING_ALIAS }, { ...opts, suppressWarnings: true, keepExtraKeys: true });
    if (value === undefined)
        return undefined;
    const output = {};
    let headings;
    if (defined(value.enumerator)) {
        const enumeratorOpts = incrementOptions('enumerator', opts);
        output.enumerator = validateNumberingItem(value.enumerator, enumeratorOpts);
        if (((_a = output.enumerator) === null || _a === void 0 ? void 0 : _a.enabled) != null) {
            if (output.enumerator.enabled !== true) {
                validationWarning("value for 'enabled' is ignored", enumeratorOpts);
            }
            delete output.enumerator.enabled;
        }
        if (((_b = output.enumerator) === null || _b === void 0 ? void 0 : _b.start) != null) {
            validationWarning("value for 'start' is ignored", enumeratorOpts);
            delete output.enumerator.start;
        }
    }
    if (defined(value.all)) {
        const allOpts = incrementOptions('all', opts);
        output.all = validateNumberingItem(value.all, allOpts);
        if (((_c = output.all) === null || _c === void 0 ? void 0 : _c.template) != null) {
            validationWarning("value for 'template' is ignored", allOpts);
            delete output.all.template;
        }
        if (((_d = output.all) === null || _d === void 0 ? void 0 : _d.start) != null) {
            validationWarning("value for 'start' is ignored", allOpts);
            delete output.all.start;
        }
    }
    if (defined(value.headings)) {
        headings = validateNumberingItem(value.headings, incrementOptions('headings', opts));
        HEADING_KEYS.forEach((headingKey) => {
            if (headings && !defined(value[headingKey])) {
                value[headingKey] = headings;
            }
        });
    }
    Object.keys(value)
        .filter((key) => !NUMBERING_OPTIONS.includes(key)) // For all the unknown options
        .forEach((key) => {
        if (defined(value[key])) {
            const item = validateNumberingItem(value[key], incrementOptions(key, opts));
            if (!defined(item))
                return;
            if (headings && HEADING_KEYS.includes(key)) {
                output[key] = { ...headings, ...item };
            }
            else {
                output[key] = item;
            }
        }
    });
    if (Object.keys(output).length === 0)
        return undefined;
    return output;
}
export function fillNumbering(base, filler) {
    const output = { ...filler, ...base };
    Object.entries(filler !== null && filler !== void 0 ? filler : {})
        .filter(([key]) => !NUMBERING_OPTIONS.includes(key))
        .forEach(([key, val]) => {
        var _a, _b, _c;
        output[key] = fillMissingKeys((_a = base === null || base === void 0 ? void 0 : base[key]) !== null && _a !== void 0 ? _a : {}, 
        // Enabling/disabling all in base overrides filler
        { ...val, enabled: (_c = (_b = base === null || base === void 0 ? void 0 : base.all) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : val.enabled }, NUMBERING_ITEM_KEYS);
    });
    return output;
}
