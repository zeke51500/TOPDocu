import { validationWarning } from 'simple-validators';
import { normalizeJsonToString } from './normalizeString.js';
export function pseudoUniqueId(kind, index, file) {
    let suffix = '';
    if (file) {
        const fileParts = file.replace('\\', '/').split('/');
        const nameParts = fileParts[fileParts.length - 1].split('.');
        if (nameParts.length === 1) {
            suffix = `-${nameParts[0]}`;
        }
        else {
            suffix = `-${nameParts.slice(0, nameParts.length - 1).join('-')}`;
        }
    }
    return `${kind}${suffix}-generated-uid-${index}`;
}
export function stashPlaceholder(value) {
    return { id: value, name: value };
}
/**
 * Return true if object:
 *   - has 2 keys and only 2 keys: id and name
 *   - the values for id and name are the same
 */
export function isStashPlaceholder(object) {
    return Object.keys(object).length === 2 && object.name && object.id && object.name === object.id;
}
/**
 * Update stash of authors/affiliations based on input value
 *
 * Input may be:
 *   - string name
 *   - string id
 *   - object without id
 *   - object with id
 *
 * This function will normalize all of the above to an id and if a corresponding
 * object does not yet exist in the stash, it will be added. The id is returned.
 *
 * This function will warn if two objects are explicitly defined with the same id.
 */
export function validateAndStashObject(input, stash, kind, validateFn, opts) {
    var _a, _b, _c;
    const lookup = {};
    const lookupNorm2Id = {};
    (_a = stash[kind]) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
        if (item.id) {
            lookup[item.id] = item;
            lookupNorm2Id[normalizeJsonToString({ ...item, id: undefined })] = item.id;
        }
    });
    if (typeof input === 'string' && Object.keys(lookup).includes(input)) {
        // Handle case where input is id and object already exists
        return input;
    }
    const value = validateFn(input, opts);
    if (!value)
        return;
    // Only warn on duplicate if the new object is not a placeholder
    let warnOnDuplicate = !isStashPlaceholder(value);
    if (!value.id) {
        if (lookupNorm2Id[normalizeJsonToString(value)]) {
            // If object is defined without an id but already exists in the stash, use the existing id
            value.id = lookupNorm2Id[normalizeJsonToString(value)];
            // Do not warn on duplicates for these; any duplicates here are identical
            warnOnDuplicate = false;
        }
        else {
            // If object is defined without an id and does not exist in the stash, generate a new id
            value.id = pseudoUniqueId(kind, (_c = (_b = stash[kind]) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0, opts.file);
        }
    }
    if (!Object.keys(lookup).includes(value.id)) {
        // Handle case of new id - add stash value
        lookup[value.id] = value;
    }
    else if (isStashPlaceholder(lookup[value.id])) {
        // Handle case of existing placeholder { id: value, name: value } - replace stash value
        lookup[value.id] = value;
    }
    else if (warnOnDuplicate) {
        // Warn on duplicate id - lose new object
        validationWarning(`duplicate id for ${kind} found in frontmatter: ${value.id}`, opts);
    }
    stash[kind] = Object.values(lookup);
    return value.id;
}
